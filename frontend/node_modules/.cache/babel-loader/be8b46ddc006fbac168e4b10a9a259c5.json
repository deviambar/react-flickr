{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"./utils\");\n\nvar EMPTY_MAP = {};\n\nfunction getNodes(node) {\n  var states = node.states;\n  var nodes = Object.keys(states).reduce(function (accNodes, stateKey) {\n    var subState = states[stateKey];\n    var subNodes = getNodes(states[stateKey]);\n    accNodes.push.apply(accNodes, [subState].concat(subNodes));\n    return accNodes;\n  }, []);\n  return nodes;\n}\n\nexports.getNodes = getNodes;\n\nfunction getEventEdges(node, event) {\n  var transitions = node.on[event];\n  return utils_1.flatMap(transitions.map(function (transition) {\n    var targets = [].concat(transition.target);\n    return targets.map(function (target) {\n      var targetNode = node.getRelativeStateNodes(target, undefined, false)[0];\n      return {\n        source: node,\n        target: targetNode,\n        event: event,\n        actions: transition.actions ? transition.actions.map(utils_1.getActionType) : [],\n        cond: transition.cond\n      };\n    });\n  }));\n}\n\nexports.getEventEdges = getEventEdges;\n\nfunction getEdges(node, options) {\n  var _a = (options || {}).deep,\n      deep = _a === void 0 ? true : _a;\n  var edges = [];\n\n  if (node.states && deep) {\n    Object.keys(node.states).forEach(function (stateKey) {\n      edges.push.apply(edges, getEdges(node.states[stateKey]));\n    });\n  }\n\n  Object.keys(node.on).forEach(function (event) {\n    edges.push.apply(edges, getEventEdges(node, event));\n  });\n  return edges;\n}\n\nexports.getEdges = getEdges;\n\nfunction getAdjacencyMap(node, extendedState) {\n  var adjacency = {};\n  var events = node.events;\n\n  function findAdjacencies(stateValue) {\n    var stateKey = JSON.stringify(stateValue);\n\n    if (adjacency[stateKey]) {\n      return;\n    }\n\n    adjacency[stateKey] = {};\n\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n      var event_1 = events_1[_i];\n      var nextState = node.transition(stateValue, event_1, extendedState);\n      adjacency[stateKey][event_1] = {\n        state: nextState.value\n      };\n      findAdjacencies(nextState.value);\n    }\n  }\n\n  findAdjacencies(node.initialState.value);\n  return adjacency;\n}\n\nexports.getAdjacencyMap = getAdjacencyMap;\n\nfunction getShortestPaths(machine, extendedState) {\n  var _a;\n\n  if (!machine.states) {\n    return EMPTY_MAP;\n  }\n\n  var adjacency = getAdjacencyMap(machine, extendedState);\n  var initialStateId = JSON.stringify(machine.initialState.value);\n  var pathMap = (_a = {}, _a[initialStateId] = [], _a);\n  var visited = new Set();\n\n  function util(stateValue) {\n    var stateId = JSON.stringify(stateValue);\n    visited.add(stateId);\n    var eventMap = adjacency[stateId];\n\n    for (var _i = 0, _a = Object.keys(eventMap); _i < _a.length; _i++) {\n      var event_2 = _a[_i];\n      var nextStateValue = eventMap[event_2].state;\n\n      if (!nextStateValue) {\n        continue;\n      }\n\n      var nextStateId = JSON.stringify(utils_1.toStateValue(nextStateValue, machine.delimiter));\n\n      if (!pathMap[nextStateId] || pathMap[nextStateId].length > pathMap[stateId].length + 1) {\n        pathMap[nextStateId] = (pathMap[stateId] || []).concat([{\n          state: stateValue,\n          event: event_2\n        }]);\n      }\n    }\n\n    for (var _b = 0, _c = Object.keys(eventMap); _b < _c.length; _b++) {\n      var event_3 = _c[_b];\n      var nextStateValue = eventMap[event_3].state;\n\n      if (!nextStateValue) {\n        continue;\n      }\n\n      var nextStateId = JSON.stringify(nextStateValue);\n\n      if (visited.has(nextStateId)) {\n        continue;\n      }\n\n      util(nextStateValue);\n    }\n\n    return pathMap;\n  }\n\n  util(machine.initialState.value);\n  return pathMap;\n}\n\nexports.getShortestPaths = getShortestPaths;\n\nfunction getShortestPathsAsArray(machine, extendedState) {\n  var result = getShortestPaths(machine, extendedState);\n  return Object.keys(result).map(function (key) {\n    return {\n      state: JSON.parse(key),\n      path: result[key]\n    };\n  });\n}\n\nexports.getShortestPathsAsArray = getShortestPathsAsArray;\n\nfunction getSimplePaths(machine, extendedState) {\n  if (!machine.states) {\n    return EMPTY_MAP;\n  }\n\n  var adjacency = getAdjacencyMap(machine, extendedState);\n  var visited = new Set();\n  var path = [];\n  var paths = {};\n\n  function util(fromPathId, toPathId) {\n    visited.add(fromPathId);\n\n    if (fromPathId === toPathId) {\n      paths[toPathId] = paths[toPathId] || [];\n      paths[toPathId].push(path.slice());\n    } else {\n      for (var _i = 0, _a = Object.keys(adjacency[fromPathId]); _i < _a.length; _i++) {\n        var subEvent = _a[_i];\n        var nextStateValue = adjacency[fromPathId][subEvent].state;\n\n        if (!nextStateValue) {\n          continue;\n        }\n\n        var nextStateId = JSON.stringify(nextStateValue);\n\n        if (!visited.has(nextStateId)) {\n          path.push({\n            state: JSON.parse(fromPathId),\n            event: subEvent\n          });\n          util(nextStateId, toPathId);\n        }\n      }\n    }\n\n    path.pop();\n    visited.delete(fromPathId);\n  }\n\n  var initialStateId = JSON.stringify(machine.initialState.value);\n  Object.keys(adjacency).forEach(function (nextStateId) {\n    util(initialStateId, nextStateId);\n  });\n  return paths;\n}\n\nexports.getSimplePaths = getSimplePaths;\n\nfunction getSimplePathsAsArray(machine, extendedState) {\n  var result = getSimplePaths(machine, extendedState);\n  return Object.keys(result).map(function (key) {\n    return {\n      state: JSON.parse(key),\n      paths: result[key]\n    };\n  });\n}\n\nexports.getSimplePathsAsArray = getSimplePathsAsArray;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","EMPTY_MAP","getNodes","node","states","nodes","keys","reduce","accNodes","stateKey","subState","subNodes","push","apply","concat","getEventEdges","event","transitions","on","flatMap","map","transition","targets","target","targetNode","getRelativeStateNodes","undefined","source","actions","getActionType","cond","getEdges","options","_a","deep","edges","forEach","getAdjacencyMap","extendedState","adjacency","events","findAdjacencies","stateValue","JSON","stringify","_i","events_1","length","event_1","nextState","state","initialState","getShortestPaths","machine","initialStateId","pathMap","visited","Set","util","stateId","add","eventMap","event_2","nextStateValue","nextStateId","toStateValue","delimiter","_b","_c","event_3","has","getShortestPathsAsArray","result","key","parse","path","getSimplePaths","paths","fromPathId","toPathId","slice","subEvent","pop","delete","getSimplePathsAsArray"],"sources":["/Users/deviambar/Documents/simpleapp/frontend/node_modules/xstate/lib/graph.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nvar EMPTY_MAP = {};\nfunction getNodes(node) {\n    var states = node.states;\n    var nodes = Object.keys(states).reduce(function (accNodes, stateKey) {\n        var subState = states[stateKey];\n        var subNodes = getNodes(states[stateKey]);\n        accNodes.push.apply(accNodes, [subState].concat(subNodes));\n        return accNodes;\n    }, []);\n    return nodes;\n}\nexports.getNodes = getNodes;\nfunction getEventEdges(node, event) {\n    var transitions = node.on[event];\n    return utils_1.flatMap(transitions.map(function (transition) {\n        var targets = [].concat(transition.target);\n        return targets.map(function (target) {\n            var targetNode = node.getRelativeStateNodes(target, undefined, false)[0];\n            return {\n                source: node,\n                target: targetNode,\n                event: event,\n                actions: transition.actions\n                    ? transition.actions.map(utils_1.getActionType)\n                    : [],\n                cond: transition.cond\n            };\n        });\n    }));\n}\nexports.getEventEdges = getEventEdges;\nfunction getEdges(node, options) {\n    var _a = (options || {}).deep, deep = _a === void 0 ? true : _a;\n    var edges = [];\n    if (node.states && deep) {\n        Object.keys(node.states).forEach(function (stateKey) {\n            edges.push.apply(edges, getEdges(node.states[stateKey]));\n        });\n    }\n    Object.keys(node.on).forEach(function (event) {\n        edges.push.apply(edges, getEventEdges(node, event));\n    });\n    return edges;\n}\nexports.getEdges = getEdges;\nfunction getAdjacencyMap(node, extendedState) {\n    var adjacency = {};\n    var events = node.events;\n    function findAdjacencies(stateValue) {\n        var stateKey = JSON.stringify(stateValue);\n        if (adjacency[stateKey]) {\n            return;\n        }\n        adjacency[stateKey] = {};\n        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n            var event_1 = events_1[_i];\n            var nextState = node.transition(stateValue, event_1, extendedState);\n            adjacency[stateKey][event_1] = { state: nextState.value };\n            findAdjacencies(nextState.value);\n        }\n    }\n    findAdjacencies(node.initialState.value);\n    return adjacency;\n}\nexports.getAdjacencyMap = getAdjacencyMap;\nfunction getShortestPaths(machine, extendedState) {\n    var _a;\n    if (!machine.states) {\n        return EMPTY_MAP;\n    }\n    var adjacency = getAdjacencyMap(machine, extendedState);\n    var initialStateId = JSON.stringify(machine.initialState.value);\n    var pathMap = (_a = {},\n        _a[initialStateId] = [],\n        _a);\n    var visited = new Set();\n    function util(stateValue) {\n        var stateId = JSON.stringify(stateValue);\n        visited.add(stateId);\n        var eventMap = adjacency[stateId];\n        for (var _i = 0, _a = Object.keys(eventMap); _i < _a.length; _i++) {\n            var event_2 = _a[_i];\n            var nextStateValue = eventMap[event_2].state;\n            if (!nextStateValue) {\n                continue;\n            }\n            var nextStateId = JSON.stringify(utils_1.toStateValue(nextStateValue, machine.delimiter));\n            if (!pathMap[nextStateId] ||\n                pathMap[nextStateId].length > pathMap[stateId].length + 1) {\n                pathMap[nextStateId] = (pathMap[stateId] || []).concat([\n                    { state: stateValue, event: event_2 }\n                ]);\n            }\n        }\n        for (var _b = 0, _c = Object.keys(eventMap); _b < _c.length; _b++) {\n            var event_3 = _c[_b];\n            var nextStateValue = eventMap[event_3].state;\n            if (!nextStateValue) {\n                continue;\n            }\n            var nextStateId = JSON.stringify(nextStateValue);\n            if (visited.has(nextStateId)) {\n                continue;\n            }\n            util(nextStateValue);\n        }\n        return pathMap;\n    }\n    util(machine.initialState.value);\n    return pathMap;\n}\nexports.getShortestPaths = getShortestPaths;\nfunction getShortestPathsAsArray(machine, extendedState) {\n    var result = getShortestPaths(machine, extendedState);\n    return Object.keys(result).map(function (key) { return ({\n        state: JSON.parse(key),\n        path: result[key]\n    }); });\n}\nexports.getShortestPathsAsArray = getShortestPathsAsArray;\nfunction getSimplePaths(machine, extendedState) {\n    if (!machine.states) {\n        return EMPTY_MAP;\n    }\n    var adjacency = getAdjacencyMap(machine, extendedState);\n    var visited = new Set();\n    var path = [];\n    var paths = {};\n    function util(fromPathId, toPathId) {\n        visited.add(fromPathId);\n        if (fromPathId === toPathId) {\n            paths[toPathId] = paths[toPathId] || [];\n            paths[toPathId].push(path.slice());\n        }\n        else {\n            for (var _i = 0, _a = Object.keys(adjacency[fromPathId]); _i < _a.length; _i++) {\n                var subEvent = _a[_i];\n                var nextStateValue = adjacency[fromPathId][subEvent].state;\n                if (!nextStateValue) {\n                    continue;\n                }\n                var nextStateId = JSON.stringify(nextStateValue);\n                if (!visited.has(nextStateId)) {\n                    path.push({ state: JSON.parse(fromPathId), event: subEvent });\n                    util(nextStateId, toPathId);\n                }\n            }\n        }\n        path.pop();\n        visited.delete(fromPathId);\n    }\n    var initialStateId = JSON.stringify(machine.initialState.value);\n    Object.keys(adjacency).forEach(function (nextStateId) {\n        util(initialStateId, nextStateId);\n    });\n    return paths;\n}\nexports.getSimplePaths = getSimplePaths;\nfunction getSimplePathsAsArray(machine, extendedState) {\n    var result = getSimplePaths(machine, extendedState);\n    return Object.keys(result).map(function (key) { return ({\n        state: JSON.parse(key),\n        paths: result[key]\n    }); });\n}\nexports.getSimplePathsAsArray = getSimplePathsAsArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}